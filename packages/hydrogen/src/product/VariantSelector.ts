import {useLocation} from '@remix-run/react';
import type {
  ProductVariant,
  SelectedOptionInput,
  Scalars,
} from '@shopify/hydrogen-react/storefront-api-types';
import {type ReactNode, useMemo, createElement, Fragment} from 'react';
import type {PartialDeep} from 'type-fest';

export type VariantOption = {
  name: string;
  value?: string;
  values: Array<VariantOptionValue>;
};

export type VariantOptionValue = {
  value: string;
  isAvailable: boolean;
  to: string;
  search: string;
  isActive: boolean;
};

// NOTE: this will come from autogenerated storefront-api-types
export type ProductOptionV2 = Node & {
  __typename?: 'ProductOption';
  /** A globally-unique ID. */
  id: Scalars['ID']['output'];
  /** The product optionâ€™s name. */
  name: Scalars['String']['output'];

  /** The corresponding value to the product option name. */
  optionValues: Array<{
    id: string;
    name: string;
    variant: ProductVariant;
  }>;
};

type VariantSelectorProps = {
  /** The product handle for all of the variants */
  handle: string;
  /** Product options from the [Storefront API](/docs/api/storefront/<TODO insert new version here>/objects/ProductOption). Make sure both `name` and `values` are apart of your query. */
  options: Array<PartialDeep<ProductOptionV2>> | undefined;
  /** By default all products are under /products. Use this prop to provide a custom path. */
  productPath?: string;
  children: ({option}: {option: VariantOption}) => ReactNode;
};

export function VariantSelector({
  handle,
  options = [],
  productPath = 'products',
  children,
}: VariantSelectorProps) {
  const {searchParams, path, alreadyOnProductPage} = useVariantPath(
    handle,
    productPath,
  );

  // If an option only has one value, it doesn't need a UI to select it
  // But instead it always needs to be added to the product options so
  // the SFAPI properly finds the variant
  const optionsWithOnlyOneValue = options.filter(
    (option) => option?.optionValues?.length === 1,
  );

  return createElement(
    Fragment,
    null,
    ...useMemo(() => {
      return (
        options
          // Only show options with more than one value
          .filter((option) => (option?.optionValues?.length ?? 1) > 1)
          .map((option) => {
            let activeValue;
            let availableValues: VariantOptionValue[] = [];

            for (let {name, variant} of option.optionValues!) {
              // The clone the search params for each value, so we can calculate
              // a new URL for each option value pair
              const clonedSearchParams = new URLSearchParams(
                alreadyOnProductPage ? searchParams : undefined,
              );
              clonedSearchParams.set(option.name!, name!);

              // Because we hide options with only one value, they aren't selectable,
              // but they still need to get into the URL
              optionsWithOnlyOneValue.forEach((option) => {
                clonedSearchParams.set(
                  option.name!,
                  option.optionValues![0]!.name!,
                );
              });

              const currentParam = searchParams.get(option.name!);

              const calculatedActiveValue = currentParam
                ? // If a URL parameter exists for the current option, check if it equals the current value
                  currentParam === name!
                : false;

              if (calculatedActiveValue) {
                // Save out the current value if it's active. This should only ever happen once.
                // Should we throw if it happens a second time?
                activeValue = name;
              }

              const searchString = '?' + clonedSearchParams.toString();

              availableValues.push({
                // the option value
                value: name!,
                // whether the variant is available, true if no variant is found (that feels wrong...)
                isAvailable: variant ? variant.availableForSale! : true,
                // this is the url that will be redirected to after clicking the option value. if this is a diff. product, it will reload all product content
                to: path + searchString,
                // this is the query string of the option values
                search: searchString,
                // isSelected equivalent
                isActive: calculatedActiveValue,
              });
            }

            return children({
              option: {
                name: option.name!,
                value: activeValue,
                values: availableValues,
              },
            });
          })
      );
    }, [options, children]),
  );
}

type GetSelectedProductOptions = (request: Request) => SelectedOptionInput[];

export const getSelectedProductOptions: GetSelectedProductOptions = (
  request,
) => {
  if (typeof request?.url === 'undefined')
    throw new TypeError(`Expected a Request instance, got ${typeof request}`);

  const searchParams = new URL(request.url).searchParams;

  const selectedOptions: SelectedOptionInput[] = [];

  searchParams.forEach((value, name) => {
    selectedOptions.push({name, value});
  });

  return selectedOptions;
};

function useVariantPath(handle: string, productPath: string) {
  const {pathname, search} = useLocation();

  return useMemo(() => {
    const match = /(\/[a-zA-Z]{2}-[a-zA-Z]{2}\/)/g.exec(pathname);
    const isLocalePathname = match && match.length > 0;
    productPath = productPath.startsWith('/')
      ? productPath.substring(1)
      : productPath;

    const path = isLocalePathname
      ? `${match![0]}${productPath}/${handle}`
      : `/${productPath}/${handle}`;

    const searchParams = new URLSearchParams(search);

    return {
      searchParams,
      // If the current pathname matches the product page, we need to make sure
      // that we append to the current search params. Otherwise all the search
      // params can be generated new.
      alreadyOnProductPage: path === pathname,
      path,
    };
  }, [pathname, search, handle, productPath]);
}
